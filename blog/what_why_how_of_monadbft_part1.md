---
title: MonadBFT 的定义、原因和方法（第 1 部分）
description: Monoscope | MonadBFT 的定义、原因和方法（第 1 部分）
image: /blog/monadbft_pt1_1.png
---

# Monoscope | MonadBFT 的定义、原因和方法（第 1 部分）

:::tip 原文
https://x.com/michael_lwy/status/1912870081421517030
翻译：Siri
:::

区块链强制执行**严格的全局共识**，这意味着在全球任何地方运行网络的每个人都对同一组客观结果达成一致。

但是，当某些参与者撒谎、离线或积极试图破坏这个过程时，分布式系统如何达成一致？

这就是共识协议发挥作用的地方。它是一套规则，允许由独立且可能不诚实的参与者组成的网络就交易的顺序和内容达成一致。

一旦你拥有这种"严格的全局共识"，区块链就会解锁数字产权、货币硬度和社会可扩展性等奇妙特性。但所有这些都取决于协议维持**安全性**（没有两个冲突的区块被最终确认）和**活性**（网络继续取得进展）的能力。

MonadBFT代表了共识协议演进中的最新飞跃。

## 过去共识机制的简要回顾

共识机制领域已经发展了几十年。早期的协议如PBFT（实用拜占庭容错）表明，即使有多达f个节点（在3f+1个节点中）是恶意的，也可以达成一致。这些经典设计通过选举一个**领导者**来工作，该领导者协调验证者之间的多轮投票。

在每个阶段（例如预准备、准备、提交、回复），每个验证者必须与其他所有验证者通信。这导致二次方消息复杂度（完全网状通信）：如果有n个验证者，你每轮大约需要n²条消息。这在小型网络中是可管理的，但随着验证者集合的增长变得不可行。

![monadbft_2](/blog/monadbft_pt1_2.png)

二次消息传递效率低下。在一个有100个验证者的网络中，你每轮必须处理数万条消息。对于全球性、无需许可的系统来说，这太沉重了。因此，早期的BFT协议如PBFT和Tendermint通常部署在许可系统或小型验证者集合中，那里的性能限制是可以接受的。

为了在无需许可的环境中扩展BFT，较新的协议选择了**线性通信**：每个验证者只与领导者对话，将消息复杂度从n²降低到n。

Hotstuff于2018年首次引入，它通过引入精简的、以领导者为中心的通信模式推动了BFT共识向前发展。

HotStuff采用**线性通信**。与PBFT中的二次方消息爆炸不同，在HotStuff中，所有验证者只向下一个领导者发送他们的投票。该领导者将它们合并为一个称为**仲裁证书（QC）**的单一紧凑证明。QC向任何观察者证明"大多数节点同意了提案"。与PBFT不同，在PBFT中每个人都与每个人进行检查（导致消息过载），HotStuff是"一次投票，一次打包"，这意味着即使网络增长，网络也保持快速。

![monadbft_3](/blog/monadbft_pt1_3.png)

此外，HotStuff可以被**流水线化**以提高效率。在原始的HotStuff协议中，同一个验证者在每轮通信中担任领导者，直到区块被最终确认，一次只处理一个区块。在流水线HotStuff中，每轮通信都有一个新的领导者，负责**既**从上一轮的投票中组装/传播仲裁证书，**又**提出一个新的区块。

在流水线HotStuff中，不是等待单个领导者完成确定区块所需的所有工作，而是每个领导者在序列中扮演一个角色。领导者1提出一个区块，然后领导者2为领导者1的区块组装并分享一个QC，同时也提出一个新的区块，依此类推。这种设置形成了一个链，每个新领导者帮助确认之前的区块，同时也提出一个新的区块。流水线实际上意味着**重叠**这些步骤（即，当一个区块正在被最终确认时，下一个区块已经在被提出）。

简而言之，基于HotStuff的协议实现了更好的去中心化和性能：它们可以包含更多的验证者，并以更少的消息和轮次最终确认区块。这些特性使HotStuff成为许多现代PoS共识实现的模板。然而，正如我们接下来将看到的，流水线设计也引入了一个不立即明显的微妙漏洞。

## 尾部分叉问题

虽然 HotStuff（更具体地说是流水线 HotStuff）解决了可扩展性问题，但其设计带来了新的挑战。流水线协议的一个主要问题是尾叉。

尾叉可以理解为链条在“尾部”的重组。当一个有效且正确传播给其他验证者的区块应该成为链的一部分（它获得了所需的投票），但由于下一个领导者的行为而最终被放弃（孤儿）时，就会发生尾叉。

本质上，一个区块被提出并由超级多数验证，但仍然无法提交，被不同高度的另一个区块取代（非常不公平，对吧？！）。

为什么会发生这种情况？在流水线HotStuff中，每个领导者有两项工作：A. 提出一个新区块，B. 为前一个领导者的区块收集投票（形成QC）。

例如，假设验证者Alice提出块 B_n，并且超级多数的验证者为其投票（足以最终形成 QC）。通常，下一位领导者Bob（正在处理块 B_n+1）应该在他的提案中包括那个 QC。

但如果Bob离线或故意错过了他的时间槽，B_n 的 QC 将不会传播，B_n 将被放弃。

![monadbft_4](/blog/monadbft_pt1_4.png)

## 为什么尾部分叉很重要？

尾部分叉是1）经济上不公平，2）对活性潜在危险。

首先是丢失奖励的问题：当一个区块被放弃时，生产该区块的领导者失去了他们本应获得的任何区块奖励或交易费用。在这个例子中，由于Bob的不当行为阻止了最终确认，Alice什么也得不到。这是不公平的，并创造了不良激励：像Bob这样的恶意行为者可以通过使其奖励无效来伤害竞争对手。诚实的验证者，即使他们做了所有正确的事情，如果下一个领导者有过错，也可能得不到报酬。随着时间的推移，这可能会阻止参与或鼓励恶意行为，如串谋（下面会详细介绍）。

第二个问题是MEV利用。尾部分叉提供了一个利用MEV的机会。假设Alice构建的区块包含了有利可图的套利交易。如果Bob是恶意的，他们可以与下一个领导者Carol串谋；Bob将故意放弃Alice的区块，Carol将在该高度用一些相同的交易重建区块，以自己捕获MEV。Bob和Carol基本上可以串谋从L2窃取MEV。这种"重新排序"攻击**鼓励串谋**，损害整体网络完整性。

第三个问题是UX和最终性保证。BFT共识的主要优势之一（与中本聪最长链协议相比）是确定性最终性：一旦区块被提交，它就是最终的，不能被重新排序。然而，尾部分叉破坏了链尖端的这一保证，那里的区块仍处于"已投票但尚未提交"状态。一些高吞吐量的dapp理想情况下希望能够在区块"投票"后立即根据区块信息采取行动，以减少延迟。尾部分叉可能导致普通用户的状态突然逆转（即，你的余额可能是错的，你刚刚执行的10倍杠杆交易丢失了，游戏状态逆转）。

第四个问题是级联故障。在大多数情况下，尾部分叉可能只导致一个区块的延迟。使用我们之前的例子，即使Alice的区块由于Bob的活性问题而被丢弃，Carol会将其拾回并继续链条（如下面来自gmonads.com的截图所示）。然而，在边缘情况下，这可能导致级联故障。如果几个领导者连续决定尾部分叉前一个区块，链将停滞，直到有人最终生成一个持久的区块。

![monadbft_5](/blog/monadbft_pt1_5.png)

尾部分叉是一个实际问题，而不仅仅是理论推测。事实上，所有之前的流水线 BFT 实现（预 MonacBFT）在某种程度上都容易受到它的影响，因为设计本质上依赖于下一个领导者最终确定当前领导者的区块。虽然有一些尝试来解决这个问题，但通常伴随着重大的权衡。例如，BeeGees 协议提出了消除尾部分叉的方法，但代价是回到二次通信。

## 什么是 MonadBFT？

MonadBFT 的创建是为了直接解决尾部分叉的脆弱性，同时保持性能提升。它建立在 HotStuff 框架之上，这意味着 1）有轮换领导者，2）流水线提交，3）线性消息传递，但引入机制来提高安全性和生存性，而不牺牲吞吐量。

MonadBFT 的首要任务是确保任何由诚实领导者提出的区块（获得了超级多数投票）不会被放弃。这里期望的结果是，如果一个区块获得了超级多数的支持，协议将确保该区块最终会被最终确定并包含在链中（不会被孤立或跳过）。执行这一点的机制是双重的：1）强制重新提案和 2）无背书证书（NEC）。

### 1.重新提案

在 BFT 协议中，时间被划分为称为“视图”的轮次。每个视图都有一个指定的领导者负责提出一个新块。如果该领导者失败，这意味着他们 1）没有及时发送提案或 2）发送了一个无效的提案，协议将移动到下一个视图，并由新的领导者接管。MonadBFT 包含一个机制，确保在这个过渡期间不会放弃任何诚实的区块。

当当前领导者失败时，验证者通过广播一个签名消息来触发视图更改，表明该轮次已超时。重要的是，这些消息还包括一些其他信息，而不仅仅是“嘿，这里有一个失败”。

每个消息还必须包含验证者看到的最近区块的引用，并为其投票。可以将其视为说：“我证明这一轮没有收到适当的提案，这是我看到的最新区块。”

新的领导者然后从超多数验证者（2f+1）那里收集这些超时消息，并将它们组合成所谓的超时证书（TC）。TC 提供了网络中最后一轮失败时最佳已知区块的快照。在这些区块中，领导者确定最先进的区块（基于区块高度或视图编号，标记为“high_tip”）。

MonadBFT 要求新领导者的提案包含由 2f+1 个验证者的超时消息形成的 TC，并重新提议 TC 中引用的最高已知待处理区块，给予该区块另一个机会以收集足够的投票并最终确定。为什么？回顾我们之前的意图。这将确保在失败之前几乎被最终确定的区块不会简单消失。

举例来说：想象验证者Alice在视图 5 中是领导者（将视图视为轮次），并提出了许多验证者投票的有效区块。但是下一个领导者B o在视图 6 中下线。当Carol在视图 7 中成为领导者时，根据 MonadBFT 的规则，为了使Carol的提案有效，她必须包含 TC，并且她必须重新提议Alice的区块。这样，Alice的诚实工作就不会浪费。

如果Carol没有Alice的区块，她会向其他节点请求该区块。这些节点可以选择提供给她该区块，或者回应一个签名的无支持（NE）消息，表示他们没有该区块（稍后会详细介绍）。 （至多 f 个节点可能选择不做回应 - 这是一种拜占庭行为。）

在重新提议Alice的区块后，Carol获得了第二个时隙，以便她不会因为Bob的失败而受到惩罚。

这一重新提议规则确保区块链公平地向前推进，并且没有有效的工作因为运气不好或坏行为而被悄悄丢弃。

### 无支持证书（NEC）

如上所述，当Bob的时隙发生超时时，Carol会向每个人请求 high_tip 区块（Alice的区块），并且至少有 2f+1 个验证者会回应Alice的区块或签名的无支持消息。

如果有人回应Alice的区块，Carol就拥有重新提议所需的信息和理由。此外，Carol有责任重新提议Alice的区块 - 她唯一不被允许的方式是如果至少有 f+1 个人签署了 NE 消息（允许Carol构建无支持证书）。

为什么是 f+1？在任何拥有 3f+1 个验证者的 BFT 系统中，至多 f 个可以是恶意的。如果Alice的区块应该留存，那么至少需要 2f+1 个诚实节点收到了该区块。为了跳过Alice的区块并在同一高度提议一个新的区块，Carol需要 f+1 个验证者签署未收到Alice区块的声明，但根据假设，只有 f 个验证者是拜占庭的。

NEC 是领导者的证明，表明跳过重提是安全和合理的。这是一张收据，说明：“这是可验证的证据，证明之前的区块并未准备好被最终确认，因此我并不是恶意忽视它。”

## 重提 + NEC = 尾部分叉抵抗

总结一下，结合重提和 NEC 机制为 MonadBFT 提供了明确的规则：要么最终确认几乎达成的内容，要么证明它并没有准备好并继续前进。没有任何东西会被遗漏。

该设计确保了尾部分叉抵抗：一个诚实的领导者的区块获得了超大多数的投票，无论如何最终都会被确认。领导者不能自私地剥离其前任的区块而不留加密痕迹，因为缺少 NEC 会暴露出他们的行为。

从经济角度来看，这保护了验证者，因为你的区块（以及奖励）不会因其他人的不当行为而被放弃。即使在串通的情况下：如果Bob故意跳过他的时隙以试图让Carol窃取Alice的区块，MonadBFT 会迫使Carol重提Alice的区块（因为它有足够的投票人数），而不是创建一个新的。Carol将最终确认Alice的区块，然后再提议她自己的区块，这意味着此次攻击没有 MEV 利益。

这里的突破在于 MonadBFT 在没有大量通信的情况下实现了这一点。之前解决尾分叉的方法（如 BeeGees）在每一轮中都强加了二次通信或非常严格的条件。MonadBFT 通过仅在发生故障时调用更广泛的通信（收集大量消息）来放宽这些条件，而不是每一轮都调用。因此，在稳健诚实的领导者的正常情况下，它仍然高效运作（关于快乐路径与不快乐路径的更多内容在第二部分）。

![monadbft_6](/blog/monadbft_pt1_6.png)

## 结论

在本文中，我们探讨了传统 PBFT 共识的机制、前几代 hotstuff 以及 MonadBFT 如何独特地解决了流水线 hotstuff 内生的尾分叉问题。

尾分叉扭曲了区块构建者的经济激励，并对网络的活力造成潜在危险。MonadBFT 引入了关于重新提议和无赞同证书（NEC）的规则，以确保由达到法定人数投票的诚实领导者提出的区块不会被孤立或放弃。

在第二部分中，我们将探讨 MonadBFT 的另外两个特征：1）投机最终性和 2）乐观响应性。我们还将探讨 MonadBFT 对验证者和开发者的影响。

敬请期待。